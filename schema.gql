directive @constraint(
  """String constraints"""
  minLength: Int
  maxLength: Int
  startsWith: String
  endsWith: String
  contains: String
  notContains: String
  pattern: String
  format: String

  """Number constraints"""
  min: Int
  max: Int
  exclusiveMin: Int
  exclusiveMax: Int
  multipleOf: Int
  uniqueTypeName: String
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

directive @cacheControl(maxAge: Int, scope: CacheControlScope, inheritMaxAge: Boolean) on FIELD_DEFINITION | OBJECT | INTERFACE | UNION

directive @cost(multipliers: [String], useMultipliers: Boolean, complexity: CostComplexity) on OBJECT | FIELD_DEFINITION

"""Rate limit within a given period of time, in seconds"""
directive @rateLimit(period: Int!, limit: Int!) on FIELD_DEFINITION

directive @auth(mode: String!, group: String) on FIELD_DEFINITION

directive @privateCache(strict: Boolean! = false) on FIELD_DEFINITION

directive @objectCache(maxAge: Int = 1000) on OBJECT | FIELD_DEFINITION

directive @logCache(type: String!) on FIELD_DEFINITION

directive @purgeCache(type: String!) on FIELD_DEFINITION

"""Exposes a URL that specifies the behaviour of this scalar."""
directive @specifiedBy(
  """The URL that specifies the behaviour of this scalar."""
  url: String!
) on SCALAR

"""
Direct the client to resolve this field locally, either from the cache or local resolvers.
"""
directive @client(
  """
  When true, the client will never use the cache for this value. See
  https://www.apollographql.com/docs/react/essentials/local-state/#forcing-resolvers-with-clientalways-true
  """
  always: Boolean
) on FIELD | FRAGMENT_DEFINITION | INLINE_FRAGMENT

"""
Export this locally resolved field as a variable to be used in the remainder of this query. See
https://www.apollographql.com/docs/react/essentials/local-state/#using-client-fields-as-variables
"""
directive @export(
  """The variable name to export this field as."""
  as: String!
) on FIELD

"""
Specify a custom store key for this result. See
https://www.apollographql.com/docs/react/advanced/caching/#the-connection-directive
"""
directive @connection(
  """Specify the store key."""
  key: String!

  """
  An array of query argument names to include in the generated custom store key.
  """
  filter: [String!]
) on FIELD

input AddArticlesTagsInput {
  id: ID!
  articles: [ID!]
  selected: Boolean
}

"""Add Credit"""
input AddCreditInput {
  amount: amount_Float_NotNull_exclusiveMin_0!
}

type AddCreditResult {
  transaction: Transaction!

  """The client secret of this PaymentIntent."""
  client_secret: String!
}

scalar amount_Float_exclusiveMin_0

scalar amount_Float_NotNull_exclusiveMin_0

scalar amount_Int_NotNull_min_1

type Announcement {
  id: ID!
  title: String
  cover: String
  content: String
  link: String
  type: AnnouncementType!
  visible: Boolean!
  order: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
  translations: [TranslatedAnnouncement!]
}

input AnnouncementsInput {
  id: ID
  visible: Boolean
}

enum AnnouncementType {
  community
  product
  seminar
}

input AppreciateArticleInput {
  id: ID!
  amount: amount_Int_NotNull_min_1!
  token: String
  superLike: Boolean
}

type Appreciation {
  amount: Int!
  purpose: AppreciationPurpose!
  content: String!

  """Timestamp of appreciation."""
  createdAt: DateTime!

  """Recipient of appreciation."""
  recipient: User!

  """Sender of appreciation."""
  sender: User

  """Object that appreciation is meant for."""
  target: Article
}

type AppreciationConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [AppreciationEdge!]
}

type AppreciationEdge {
  cursor: String!
  node: Appreciation!
}

enum AppreciationPurpose {
  appreciate
  appreciateComment
  appreciateSubsidy
  invitationAccepted
  joinByInvitation
  joinByTask
  firstPost
  systemSubsidy
}

"""
This type contains metadata, content, hash and related data of an article. If you
want information about article's comments. Please check Comment type.
"""
type Article implements Node {
  """Unique ID of this article"""
  id: ID!

  """The number represents how popular is this article."""
  topicScore: Int

  """Slugified article title."""
  slug: String!

  """Time of this article was created."""
  createdAt: DateTime!

  """Time of this article was revised."""
  revisedAt: DateTime

  """State of this article."""
  state: ArticleState!

  """Author of this article."""
  author: User!

  """Article title."""
  title: String!

  """Article cover's link."""
  cover: String

  """
  List of assets are belonged to this article (Only the author can access currently).
  """
  assets: [Asset!]!

  """A short summary for this article."""
  summary: String!

  """This value determines if the summary is customized or not."""
  summaryCustomized: Boolean!

  """Tags attached to this article."""
  tags: [Tag!]

  """Word count of this article."""
  wordCount: Int

  """IPFS hash of this article."""
  dataHash: String!

  """Media hash, composed of cid encoding, of this article."""
  mediaHash: String!

  """Content (HTML) of this article."""
  content: String!

  """Different foramts of content."""
  contents: ArticleContents!

  """Original language of content"""
  language: String

  """List of articles which added this article into their collections."""
  collectedBy(input: ConnectionArgs!): ArticleConnection!

  """List of articles added into this article' collection."""
  collection(input: ConnectionArgs!): ArticleConnection!

  """Related articles to this article."""
  relatedArticles(input: ConnectionArgs!): ArticleConnection!

  """Donation-related articles to this article."""
  relatedDonationArticles(input: RelatedDonationArticlesInput!): ArticleConnection!

  """Appreciations history of this article."""
  appreciationsReceived(input: ConnectionArgs!): AppreciationConnection!

  """Total number of appreciations recieved of this article."""
  appreciationsReceivedTotal: Int!

  """Subscribers of this article."""
  subscribers(input: ConnectionArgs!): UserConnection!

  """Limit the nuhmber of appreciate per user."""
  appreciateLimit: Int!

  """Number represents how many times per user can appreciate this article."""
  appreciateLeft: Int!

  """This value determines if current viewer has appreciated or not."""
  hasAppreciate: Boolean!

  """This value determines if current viewer can SuperLike or not."""
  canSuperLike: Boolean!

  """This value determines if current Viewer has subscribed of not."""
  subscribed: Boolean!

  """
  This value determines if this article is an author selected article or not.
  """
  sticky: Boolean!

  """Translation of article title and content."""
  translation(input: TranslationArgs): ArticleTranslation

  """Available translation languages."""
  availableTranslations: [UserLanguage!]

  """Transactions history of this article."""
  transactionsReceivedBy(input: TransactionsReceivedByArgs!): UserConnection!

  """Cumulative reading time in seconds"""
  readTime: Float!

  """Drafts linked to this article."""
  drafts: [Draft!] @deprecated(reason: "Use Article.newestUnpublishedDraft or Article.newestPublishedDraft instead")

  """Newest unpublished draft linked to this article."""
  newestUnpublishedDraft: Draft

  """Newest published draft linked to this article."""
  newestPublishedDraft: Draft!

  """Revision Count"""
  revisionCount: Int!

  """Access related fields on circle"""
  access: ArticleAccess!

  """whether content is marked as sensitive by author"""
  sensitiveByAuthor: Boolean!

  """whether content is marked as sensitive by admin"""
  sensitiveByAdmin: Boolean!

  """License Type"""
  license: ArticleLicenseType!

  """creator message asking for support"""
  requestForDonation: String

  """creator message after support"""
  replyToDonator: String

  """the iscnId if published to ISCN"""
  iscnId: String

  """whether readers can comment"""
  canComment: Boolean!

  """
  #############
       OSS    #
  #############
  """
  oss: ArticleOSS!
  remark: String

  """The counting number of comments."""
  commentCount: Int!

  """The number determines how many pinned comments can be set."""
  pinCommentLimit: Int!

  """The number determines how many comments can be set as pinned comment."""
  pinCommentLeft: Int!

  """List of pinned comments."""
  pinnedComments: [Comment!]

  """List of featured comments of this article."""
  featuredComments(input: FeaturedCommentsInput!): CommentConnection!

  """List of comments of this article."""
  comments(input: CommentsInput!): CommentConnection!

  """The counting number of this article."""
  responseCount: Int!

  """List of responses of a article."""
  responses(input: ResponsesInput!): ResponseConnection!
}

type ArticleAccess {
  type: ArticleAccessType!
  secret: String
  circle: Circle
}

"""Enums for types of article access"""
enum ArticleAccessType {
  public
  paywall
}

type ArticleArticleNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """List of notice actors."""
  actors: [User!]
  type: ArticleArticleNoticeType!
  target: Article!
  article: Article!
}

enum ArticleArticleNoticeType {
  ArticleNewCollected
}

type ArticleConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [ArticleEdge!]
}

type ArticleContents {
  """Markdown content of this article."""
  markdown: String!

  """HTML content of this article."""
  html: String!
}

type ArticleEdge {
  cursor: String!
  node: Article!
}

input ArticleInput {
  mediaHash: String!
}

"""Enums for types of article license"""
enum ArticleLicenseType {
  cc_0
  cc_by_nc_nd_2
  cc_by_nc_nd_4
  arr
}

"""
################################
                               #
           Article             #
                               #
################################
"""
type ArticleNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """List of notice actors."""
  actors: [User!]
  type: ArticleNoticeType!
  target: Article!
}

enum ArticleNoticeType {
  ArticlePublished
  ArticleMentionedYou
  ArticleNewSubscriber
  ArticleNewAppreciation
  RevisedArticlePublished
  RevisedArticleNotPublished
  CircleNewArticle
}

type ArticleOSS {
  boost: Float!
  score: Float!
  inRecommendIcymi: Boolean!
  inRecommendHottest: Boolean!
  inRecommendNewest: Boolean!
}

type ArticleRecommendationActivity {
  """The source type of recommendation"""
  source: ArticleRecommendationActivitySource

  """Recommended articles"""
  nodes: [Article!]
}

enum ArticleRecommendationActivitySource {
  UserDonation
  ReadArticlesTags
}

"""Enums for an article state."""
enum ArticleState {
  active
  archived
  banned
}

"""
################################
                               #
             Tag               #
                               #
################################
"""
type ArticleTagNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """List of notice actors."""
  actors: [User!]
  type: ArticleTagNoticeType!
  target: Article!
  tag: Tag!
}

enum ArticleTagNoticeType {
  ArticleTagAdded
  ArticleTagRemoved
  ArticleTagUnselected @deprecated(reason: "No longer in use")
}

type ArticleTranslation {
  title: String
  content: String
  summary: String
  language: String
}

"""This type contains type, link and related data of an asset."""
type Asset {
  """Unique ID of this Asset."""
  id: ID!

  """Types of this asset."""
  type: AssetType!

  """Link of this asset."""
  path: String!

  """Time of this asset was created."""
  createdAt: DateTime!
}

"""Enums for asset types."""
enum AssetType {
  avatar
  cover
  embed
  embedaudio
  profileCover
  oauthClientAvatar
  tagCover
  circleAvatar
  circleCover
  announcementCover
  topicCover

  """img-cached"""
  imgCached
}

enum AuthorsType {
  active
  appreciated
  default
  trendy
}

type AuthResult {
  auth: Boolean!
  token: String
  type: AuthResultType!
  user: User
}

enum AuthResultType {
  Login
  Signup
  LinkAccount
}

type Badge {
  type: BadgeType!
}

input BadgedUsersInput {
  after: String
  first: first_Int_min_0
  type: BadgeType
}

enum BadgeType {
  seed
  golden_motor
  architect
}

type Balance {
  HKD: Float!
}

scalar banDays_Int_exclusiveMin_0

type BlockchainTransaction {
  chain: Chain!
  txHash: String!
}

type BlockedSearchKeyword {
  """Unique ID of bloked search keyword."""
  id: ID!

  """Types of this search keyword."""
  searchKey: String!

  """Time of this search keyword was created."""
  createdAt: DateTime!
}

scalar boost_Float_NotNull_min_0

enum BoostTypes {
  Article
  User
  Tag
}

"""
###################
    Directives    #
###################
"""
enum CacheControlScope {
  PUBLIC
  PRIVATE
}

enum Chain {
  Polygon
}

input ChangeEmailInput {
  oldEmail: oldEmail_String_NotNull_format_email!
  oldEmailCodeId: ID!
  newEmail: newEmail_String_NotNull_format_email!
  newEmailCodeId: ID!
}

"""
This type contains metadata, content and related data of Chapter type, which is
a container for Article type. A Chapter belong to a Topic.
"""
type Chapter implements Node {
  """Unique id of this chapter."""
  id: ID!

  """Title of this chapter."""
  title: String!

  """Description of this chapter."""
  description: String

  """Number articles included in this chapter."""
  articleCount: Int!

  """Articles included in this Chapter"""
  articles: [Article!]

  """The topic that this Chapter belongs to."""
  topic: Topic!
}

type Circle implements Node {
  """Unique ID."""
  id: ID!

  """Circle avatar's link."""
  avatar: String @deprecated(reason: "No longer in use")

  """Circle cover's link."""
  cover: String @deprecated(reason: "No longer in use")

  """Slugified name of this Circle."""
  name: String! @deprecated(reason: "No longer in use")

  """Human readable name of this Circle."""
  displayName: String! @deprecated(reason: "No longer in use")

  """A short description of this Circle."""
  description: String

  """Prices offered by this Circle."""
  prices: [Price!]

  """Circle owner."""
  owner: User!

  """List of Circle member."""
  members(input: ConnectionArgs!): MemberConnection! @deprecated(reason: "No longer in use")

  """List of Circle follower."""
  followers(input: ConnectionArgs!): UserConnection! @deprecated(reason: "No longer in use")

  """List of works belong to this Circle."""
  works(input: ConnectionArgs!): ArticleConnection! @deprecated(reason: "No longer in use")

  """State of this Circle."""
  state: CircleState! @deprecated(reason: "No longer in use")

  """Created time."""
  createdAt: DateTime! @deprecated(reason: "No longer in use")

  """Updated time."""
  updatedAt: DateTime! @deprecated(reason: "No longer in use")

  """This value determines if current viewer is following Circle or not."""
  isFollower: Boolean! @deprecated(reason: "No longer in use")

  """This value determines if current viewer is Member or not."""
  isMember: Boolean! @deprecated(reason: "No longer in use")

  """Invitations belonged to this Circle."""
  invites: Invites!

  """Invitation used by current viewer."""
  invitedBy: Invitation

  """Analytics dashboard."""
  analytics: CircleAnalytics!

  """Comments broadcasted by Circle owner."""
  broadcast(input: CommentsInput!): CommentConnection!

  """Pinned comments broadcasted by Circle owner."""
  pinnedBroadcast: [Comment!]

  """Comments made by Circle member."""
  discussion(input: CommentsInput!): CommentConnection!

  """Discussion (exclude replies) count of this circle."""
  discussionThreadCount: Int!

  """Discussion (include replies) count of this circle."""
  discussionCount: Int!
}

type CircleAnalytics {
  income: CircleIncomeAnalytics!
  subscriber: CircleSubscriberAnalytics!
  follower: CircleFollowerAnalytics!
  content: CircleContentAnalytics!
}

type CircleConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [CircleEdge!]
}

type CircleContentAnalytics {
  public: [CircleContentAnalyticsDatum!]
  paywall: [CircleContentAnalyticsDatum!]
}

type CircleContentAnalyticsDatum {
  node: Article!
  readCount: Int!
}

type CircleEdge {
  cursor: String!
  node: Circle!
}

type CircleFollowerAnalytics {
  """subscriber count history of last 4 months"""
  history: [MonthlyDatum!]!

  """current follower count"""
  current: Int!

  """the percentage of follower count in reader count of circle articles"""
  followerPercentage: Float!
}

type CircleIncomeAnalytics {
  """income history of last 4 months"""
  history: [MonthlyDatum!]!

  """total income of all time"""
  total: Float!

  """income of this month"""
  thisMonth: Float!

  """income of next month"""
  nextMonth: Float!
}

input CircleInput {
  """Slugified name of a Circle."""
  name: String!
}

"""
################################
                               #
            Circle             #
                               #
################################
"""
type CircleNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """List of notice actors."""
  actors: [User!]
  type: CircleNoticeType!
  target: Circle!

  """Optional discussion/broadcast comments for bundled notices"""
  comments: [Comment!]

  """Optional discussion/broadcast replies for bundled notices"""
  replies: [Comment!]

  """Optional mention comments for bundled notices"""
  mentions: [Comment!]
}

enum CircleNoticeType {
  CircleInvitation
  CircleNewSubscriber
  CircleNewFollower
  CircleNewUnsubscriber
  CircleNewBroadcastComments
  CircleNewDiscussionComments
}

type CircleRecommendationActivity {
  """The source type of recommendation"""
  source: CircleRecommendationActivitySource

  """Recommended circles"""
  nodes: [Circle!]
}

enum CircleRecommendationActivitySource {
  UserSubscription
}

enum CircleState {
  active
  archived
}

type CircleSubscriberAnalytics {
  """subscriber count history of last 4 months"""
  subscriberHistory: [MonthlyDatum!]!

  """invitee count history of last 4 months"""
  inviteeHistory: [MonthlyDatum!]!

  """current subscriber count"""
  currentSubscriber: Int!

  """current invitee count"""
  currentInvitee: Int!
}

input ClaimLogbooksInput {
  ethAddress: String!

  """the message being sign'ed, including nonce"""
  signedMessage: String!

  """sign'ed by wallet"""
  signature: String!

  """nonce from generateSigningMessage"""
  nonce: String!
}

type ClaimLogbooksResult {
  """claimed token ids"""
  ids: [ID!]

  """transaction hash"""
  txHash: String!
}

input ClearReadHistoryInput {
  id: ID
}

"""
This type contains content, author, descendant comments and related data of a comment.
"""
type Comment implements Node {
  """Unique ID of this comment."""
  id: ID!

  """State of this comment."""
  state: CommentState!
  type: CommentType!

  """Time of this comment was created."""
  createdAt: DateTime!

  """Content of this comment."""
  content: String

  """Author of this comment."""
  author: User!

  """This value determines this comment is pinned or not."""
  pinned: Boolean!

  """This value determines this comment is from article donator or not."""
  fromDonator: Boolean!

  """The counting number of upvotes."""
  upvotes: Int!

  """The counting number of downvotes."""
  downvotes: Int! @deprecated(reason: "No longer in use in querying")

  """The value determines current user's vote."""
  myVote: Vote

  """Descendant comments of this comment."""
  comments(input: CommentCommentsInput!): CommentConnection!

  """Parent comment of this comment."""
  parentComment: Comment

  """A Comment that this comment replied to."""
  replyTo: Comment
  remark: String

  """Current comment belongs to which Node."""
  node: Node!
}

type CommentCommentNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """List of notice actors."""
  actors: [User!]
  type: CommentCommentNoticeType!
  target: Comment!
  comment: Comment!
}

enum CommentCommentNoticeType {
  CommentNewReply
}

input CommentCommentsInput {
  author: ID
  sort: CommentSort
  after: String
  first: first_Int_min_0
}

type CommentConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [CommentEdge!]
}

type CommentEdge {
  cursor: String!
  node: Comment!
}

input CommentInput {
  content: String!
  replyTo: ID
  parentId: ID
  mentions: [ID!]
  type: CommentType!

  """one of the following ids is required"""
  articleId: ID
  circleId: ID
}

"""
################################
                               #
           Comment             #
                               #
################################
"""
type CommentNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """List of notice actors."""
  actors: [User!]
  type: CommentNoticeType!
  target: Comment!
}

enum CommentNoticeType {
  CommentPinned
  CommentMentionedYou
  ArticleNewComment
  SubscribedArticleNewComment
  CircleNewBroadcast
}

input CommentsFilter {
  parentComment: ID
  state: CommentState
  author: ID
}

input CommentsInput {
  sort: CommentSort
  after: String
  before: String
  includeAfter: Boolean
  includeBefore: Boolean
  first: first_Int_min_0
  filter: CommentsFilter
}

"""Enums for sorting comments by time."""
enum CommentSort {
  oldest
  newest
}

"""Enums for comment state."""
enum CommentState {
  active
  archived
  banned
  collapsed
}

enum CommentType {
  article
  circleDiscussion
  circleBroadcast
}

input ConfirmVerificationCodeInput {
  email: email_String_NotNull_format_email!
  type: VerificationCodeType!
  code: String!
}

interface Connection {
  totalCount: Int!
  pageInfo: PageInfo!
}

input ConnectionArgs {
  after: String
  first: first_Int_min_0
  oss: Boolean
  filter: FilterInput
}

"""Stripe Account"""
input ConnectStripeAccountInput {
  country: StripeAccountCountry!
}

type ConnectStripeAccountResult {
  redirectUrl: String!
}

input CostComplexity {
  min: Int = 1
  max: Int
}

type CryptoWallet {
  id: ID!
  address: String!

  """ does this address own any Travelogger NFTs? this value is cached at most 1day, and refreshed at next `nfts` query 
  """
  hasNFTs: Boolean!

  """NFT assets owned by this wallet address"""
  nfts: [NFTAsset!]
}

enum CryptoWalletSignaturePurpose {
  airdrop
  connect
  signup
  login
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
`date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DeleteAnnouncementsInput {
  ids: [ID!]
}

input DeleteArticlesTagsInput {
  id: ID!
  articles: [ID!]
}

input DeleteCommentInput {
  id: ID!
}

input DeleteDraftInput {
  id: ID!
}

input DeleteTagsInput {
  ids: [ID!]!
}

input DeleteTopicsInput {
  ids: [ID!]!
}

"""
This type contains content, collections, assets and related data of a draft.
"""
type Draft implements Node {
  """Unique ID of this draft."""
  id: ID!

  """Media hash, composed of cid encoding, of this draft."""
  mediaHash: String

  """Draft title."""
  title: String

  """Slugified draft title."""
  slug: String!

  """Summary of this draft."""
  summary: String

  """This value determines if the summary is customized or not."""
  summaryCustomized: Boolean!

  """Content (HTML) of this draft."""
  content: String

  """Time of this draft was created."""
  createdAt: DateTime!

  """Last time of this draft was upadted."""
  updatedAt: DateTime!

  """The counting number of words in this draft."""
  wordCount: Int!

  """Tags are attached to this draft."""
  tags: [String!]

  """Draft's cover link."""
  cover: String

  """State of draft during publihsing."""
  publishState: PublishState!

  """List of assets are belonged to this draft."""
  assets: [Asset!]!

  """Published article"""
  article: Article

  """Collection list of this draft."""
  collection(input: ConnectionArgs!): ArticleConnection!

  """Access related fields on circle"""
  access: DraftAccess!

  """whether content is marked as sensitive by author"""
  sensitiveByAuthor: Boolean!

  """License Type"""
  license: ArticleLicenseType!

  """creator message asking for support"""
  requestForDonation: String

  """creator message after support"""
  replyToDonator: String

  """whether publish to ISCN"""
  iscnPublish: Boolean

  """whether readers can comment"""
  canComment: Boolean!
}

type DraftAccess {
  type: ArticleAccessType!
  circle: Circle
}

type DraftConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [DraftEdge!]
}

type DraftEdge {
  cursor: String!
  node: Draft!
}

input EditArticleInput {
  id: ID!
  state: ArticleState
  sticky: Boolean
  summary: String
  tags: [String!]
  content: String
  cover: ID
  collection: [ID!]
  circle: ID
  accessType: ArticleAccessType
  sensitive: Boolean
  license: ArticleLicenseType
  requestForDonation: requestForDonation_String_maxLength_140
  replyToDonator: replyToDonator_String_maxLength_140

  """whether publish to ISCN"""
  iscnPublish: Boolean

  """whether readers can comment"""
  canComment: Boolean
}

scalar email_String_format_email

scalar email_String_NotNull_format_email

enum EntityType {
  article
  draft
  tag
  user
  circle
  announcement
  topic
}

type ExchangeRate {
  from: TransactionCurrency!
  to: QuoteCurrency!
  rate: Float!

  """Last updated time from currency convertor APIs"""
  updatedAt: DateTime!
}

input ExchangeRatesInput {
  from: TransactionCurrency
  to: QuoteCurrency
}

type Feature {
  name: FeatureName!
  enabled: Boolean!
}

input FeaturedCommentsInput {
  sort: CommentSort
  after: String
  first: first_Int_min_0
}

input FeaturedTagsInput {
  """ tagIds """
  ids: [ID!]!
}

enum FeatureFlag {
  on
  off
  admin
  seeding
}

enum FeatureName {
  add_credit
  payment
  payout
  verify_appreciate
  fingerprint
  tag_adoption
  circle_management
  circle_interact
}

input FilterInput {
  """index of list, min: 0, max: 49"""
  random: random_Int_min_0_max_49

  """Used in RecommendInput"""
  followed: Boolean

  """Used in User.topics"""
  public: Boolean

  """Used in User Articles filter, by tags or by time range, or both"""
  tagIds: [ID!]
  inRangeStart: DateTime
  inRangeEnd: DateTime
}

scalar first_Int_min_0

type Following {
  circles(input: ConnectionArgs!): CircleConnection!
  tags(input: ConnectionArgs!): TagConnection!
  users(input: ConnectionArgs!): UserConnection!
}

union FollowingActivity = UserPublishArticleActivity | UserAddArticleTagActivity | UserBroadcastCircleActivity | UserCreateCircleActivity | UserRecommendationActivity | ArticleRecommendationActivity | CircleRecommendationActivity

type FollowingActivityConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [FollowingActivityEdge!]
}

type FollowingActivityEdge {
  cursor: String!
  node: FollowingActivity!
}

scalar freePeriod_Int_NotNull_exclusiveMin_0

input FrequentSearchInput {
  key: String
  first: first_Int_min_0
}

input GenerateSigningMessageInput {
  address: String!
  purpose: SigningMessagePurpose
}

enum GrantType {
  authorization_code
  refresh_token
}

type Invitation {
  """Unique ID."""
  id: ID!

  """Target person of this invitation."""
  invitee: Invitee!

  """Creator of this invitation."""
  inviter: User!

  """Invitation of current Circle."""
  circle: Circle!

  """Free period of this invitation."""
  freePeriod: Int!

  """Created time."""
  createdAt: DateTime!

  """Sent time."""
  sentAt: DateTime!

  """Accepted time."""
  acceptedAt: DateTime

  """Determine it's specific state."""
  state: InvitationState!
}

type InvitationConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [InvitationEdge!]
}

type InvitationEdge {
  cursor: String!
  node: Invitation!
}

enum InvitationState {
  accepted
  pending
  transfer_succeeded
  transfer_failed
}

input InviteCircleInput {
  invitees: [InviteCircleInvitee!]!
  freePeriod: freePeriod_Int_NotNull_exclusiveMin_0!
  circleId: ID!
}

input InviteCircleInvitee {
  id: ID
  email: String
}

union Invitee = Person | User

type Invites {
  """Accepted invitation list"""
  accepted(input: ConnectionArgs!): InvitationConnection!

  """Pending invitation list"""
  pending(input: ConnectionArgs!): InvitationConnection!
}

input KeywordInput {
  keyword: String!
}

input KeywordsInput {
  keywords: [String!]
}

type Liker {
  """Liker ID of LikeCoin"""
  likerId: String

  """Whether liker is a civic liker"""
  civicLiker: Boolean!

  """Total LIKE left in wallet."""
  total: Float!

  """Rate of LikeCoin/USD"""
  rateUSD: Float @deprecated(reason: "No longer in use")
}

scalar link_String_format_uri

input LogRecordInput {
  type: LogRecordTypes!
}

enum LogRecordTypes {
  ReadFolloweeArticles
  ReadFollowingFeed
  ReadResponseInfoPopUp
}

type Member {
  """User who join to a Circle."""
  user: User!

  """Price chosen by user when joining a Circle."""
  price: Price!
}

type MemberConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [MemberEdge!]
}

type MemberEdge {
  cursor: String!
  node: Member!
}

input MergeTagsInput {
  ids: [ID!]!
  content: String!
}

input MigrationInput {
  type: MigrationType
  files: [Upload]!
}

enum MigrationType {
  medium
}

type MonthlyDatum {
  value: Float!
  date: DateTime!
}

type Mutation {
  """Publish an article onto IPFS."""
  publishArticle(input: PublishArticleInput!): Draft!

  """Edit an article."""
  editArticle(input: EditArticleInput!): Article!

  """Subscribe or Unsubscribe article"""
  toggleSubscribeArticle(input: ToggleItemInput!): Article!

  """Appreciate an article."""
  appreciateArticle(input: AppreciateArticleInput!): Article!

  """Read an article."""
  readArticle(input: ReadArticleInput!): Article!

  """
  Create a Topic when no id is given, update fields when id is given. Throw error if no id & no title.
  """
  putTopic(input: PutTopicInput!): Topic!

  """
  Create a Chapter when no id is given, update fields when id is given. Throw
  error if no id & no title, or no id & no topic.
  """
  putChapter(input: PutChapterInput!): Chapter!

  """Delete topics"""
  deleteTopics(input: DeleteTopicsInput!): Boolean!

  """Sort topics"""
  sortTopics(input: SortTopicsInput!): [Topic!]!

  """Follow or unfollow tag."""
  toggleFollowTag(input: ToggleItemInput!): Tag!

  """pin or unpin tag."""
  togglePinTag(input: ToggleItemInput!): Tag!

  """Create or update tag."""
  putTag(input: PutTagInput!): Tag!

  """Update member, permission and othters of a tag."""
  updateTagSetting(input: UpdateTagSettingInput!): Tag!

  """Add one tag to articles."""
  addArticlesTags(input: AddArticlesTagsInput!): Tag!

  """Update articles' tag."""
  updateArticlesTags(input: UpdateArticlesTagsInput!): Tag!

  """Delete one tag from articles"""
  deleteArticlesTags(input: DeleteArticlesTagsInput!): Tag!

  """
  #############
       OSS    #
  #############
  """
  toggleArticleRecommend(input: ToggleRecommendInput!): Article!
  updateArticleState(input: UpdateArticleStateInput!): Article!
  updateArticleSensitive(input: UpdateArticleSensitiveInput!): Article!
  toggleTagRecommend(input: ToggleRecommendInput!): Tag!
  deleteTags(input: DeleteTagsInput!): Boolean
  renameTag(input: RenameTagInput!): Tag!
  mergeTags(input: MergeTagsInput!): Tag!

  """Create or update a Circle."""
  putCircle(input: PutCircleInput!): Circle!

  """Follow or unfollow a Circle."""
  toggleFollowCircle(input: ToggleItemInput!): Circle! @deprecated(reason: "No longer in use")

  """Subscribe a Circle."""
  subscribeCircle(input: SubscribeCircleInput!): SubscribeCircleResult!

  """Unsubscribe a Circle."""
  unsubscribeCircle(input: UnsubscribeCircleInput!): Circle!

  """Add or remove Circle's articles"""
  putCircleArticles(input: PutCircleArticlesInput!): Circle! @deprecated(reason: "No longer in use")

  """Invite others to join circle"""
  invite(input: InviteCircleInput!): [Invitation!]

  """Publish or update a comment."""
  putComment(input: PutCommentInput!): Comment!

  """Remove a comment."""
  deleteComment(input: DeleteCommentInput!): Comment!

  """Pin or Unpin a comment."""
  togglePinComment(input: ToggleItemInput!): Comment!

  """Upvote or downvote a comment."""
  voteComment(input: VoteCommentInput!): Comment!

  """Unvote a comment."""
  unvoteComment(input: UnvoteCommentInput!): Comment!

  """Update a comments' state."""
  updateCommentsState(input: UpdateCommentsStateInput!): [Comment!]!

  """Pin a comment."""
  pinComment(input: PinCommentInput!): Comment!

  """Unpin a comment."""
  unpinComment(input: UnpinCommentInput!): Comment!

  """Create or update a draft."""
  putDraft(input: PutDraftInput!): Draft!

  """Remove a draft."""
  deleteDraft(input: DeleteDraftInput!): Boolean

  """Mark all received notices as read."""
  markAllNoticesAsRead: Boolean

  """Upload a single file."""
  singleFileUpload(input: SingleFileUploadInput!): Asset!

  """Add specific user behavior record."""
  logRecord(input: LogRecordInput!): Boolean

  """Add blocked search keyword to blocked_search_word db"""
  addBlockedSearchKeyword(input: KeywordInput!): BlockedSearchKeyword!

  """Delete blocked search keywords from search_history db"""
  deleteBlockedSearchKeywords(input: KeywordsInput!): Boolean

  """
  #############
       OSS    #
  #############
  """
  setBoost(input: SetBoostInput!): Node!
  putRemark(input: PutRemarkInput!): String
  putSkippedListItem(input: PutSkippedListItemInput!): [SkippedListItem!]
  setFeature(input: SetFeatureInput!): Feature!
  toggleSeedingUsers(input: ToggleSeedingUsersInput!): [User]!
  putAnnouncement(input: PutAnnouncementInput!): Announcement!
  deleteAnnouncements(input: DeleteAnnouncementsInput!): Boolean!
  putRestrictedUsers(input: PutRestrictedUsersInput!): [User!]!

  """Send verification code for email."""
  sendVerificationCode(input: SendVerificationCodeInput!): Boolean

  """Confirm verification code from email."""
  confirmVerificationCode(input: ConfirmVerificationCodeInput!): ID!

  """Reset user or payment password."""
  resetPassword(input: ResetPasswordInput!): Boolean

  """Change user email."""
  changeEmail(input: ChangeEmailInput!): User!

  """Set user currency preference."""
  setCurrency(input: SetCurrencyInput!): User!

  """Register user, can only be used on matters.{town,news} website."""
  userRegister(input: UserRegisterInput!): AuthResult!

  """Login user."""
  userLogin(input: UserLoginInput!): AuthResult!

  """Get signing message."""
  generateSigningMessage(input: GenerateSigningMessageInput!): SigningMessageResult!

  """Login/Signup via a wallet."""
  walletLogin(input: WalletLoginInput!): AuthResult!

  """Reset crypto wallet."""
  resetWallet(input: ResetWalletInput!): User!

  """Logout user."""
  userLogout: Boolean!

  """Generate or claim a Liker ID through LikeCoin"""
  generateLikerId: User!

  """Reset Liker ID"""
  resetLikerId(input: ResetLikerIdInput!): User!

  """Update user information."""
  updateUserInfo(input: UpdateUserInfoInput!): User!

  """Update user notification settings."""
  updateNotificationSetting(input: UpdateNotificationSettingInput!): User!

  """Follow or Unfollow current user."""
  toggleFollowUser(input: ToggleItemInput!): User!

  """Block or Unblock a given user."""
  toggleBlockUser(input: ToggleItemInput!): User!

  """Clear read history for user."""
  clearReadHistory(input: ClearReadHistoryInput!): User!

  """Clear search history for user."""
  clearSearchHistory: Boolean

  """Migrate articles from other service provider."""
  migration(input: MigrationInput!): Boolean

  """Let Traveloggers owner claims a Logbook, returns transaction hash"""
  claimLogbooks(input: ClaimLogbooksInput!): ClaimLogbooksResult!

  """update tags for showing on profile page"""
  putFeaturedTags(input: FeaturedTagsInput!): [Tag!]

  """Update state of a user, used in OSS."""
  updateUserState(input: UpdateUserStateInput!): [User!]

  """Update state of a user, used in OSS."""
  updateUserRole(input: UpdateUserRoleInput!): User!

  """Update state of a user, used in OSS."""
  refreshIPNSFeed(input: RefreshIPNSFeedInput!): User!
  toggleUsersBadge(input: ToggleUsersBadgeInput!): [User]!
  unbindLikerId(input: UnbindLikerIdInput!): User!

  """Add Credit to User Wallet"""
  addCredit(input: AddCreditInput!): AddCreditResult!

  """Pay to another user or article"""
  payTo(input: PayToInput!): PayToResult!

  """Payout to user"""
  payout(input: PayoutInput!): Transaction!

  """Create Stripe Connect account for Payout"""
  connectStripeAccount(input: ConnectStripeAccountInput!): ConnectStripeAccountResult!

  """Create or Update an OAuth Client, used in OSS."""
  putOAuthClient(input: PutOAuthClientInput!): OAuthClient
}

scalar newEmail_String_NotNull_format_email

""" NFT Asset """
type NFTAsset {
  id: ID!
  name: String!
  description: String
  imageUrl: String!
  imagePreviewUrl: String

  """imageOriginalUrl: String!"""
  contractAddress: String!
  collectionName: String!
}

interface Node {
  id: ID!
}

input NodeInput {
  id: ID!
}

input NodesInput {
  ids: [ID!]!
}

"""This interface contains common fields of a notice."""
interface Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!
}

type NoticeConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [NoticeEdge!]
}

type NoticeEdge {
  cursor: String!
  node: Notice!
}

type NotificationSetting {
  enable: Boolean!
  email: Boolean!
  mention: Boolean!
  userNewFollower: Boolean!
  articleNewComment: Boolean!
  articleNewAppreciation: Boolean!
  articleNewSubscription: Boolean!
  articleNewCollected: Boolean!
  articleSubscribedNewComment: Boolean!
  articleCommentPinned: Boolean!

  """for circle owners"""
  circleNewSubscriber: Boolean!
  circleNewFollower: Boolean!
  circleNewUnsubscriber: Boolean!
  circleMemberNewBroadcastReply: Boolean!
  circleMemberNewDiscussion: Boolean!
  circleMemberNewDiscussionReply: Boolean!

  """for circle members & followers"""
  inCircleNewArticle: Boolean!
  inCircleNewBroadcast: Boolean!
  inCircleNewBroadcastReply: Boolean!
  inCircleNewDiscussion: Boolean!
  inCircleNewDiscussionReply: Boolean!
}

enum NotificationSettingType {
  enable
  email
  mention
  userNewFollower
  articleNewComment
  articleNewAppreciation
  articleNewSubscription
  articleNewCollected
  articleSubscribedNewComment
  articleCommentPinned

  """for circle owners"""
  circleNewSubscriber
  circleNewFollower
  circleNewUnsubscriber
  circleNewDiscussion
  circleMemberBroadcast
  circleMemberNewDiscussion
  circleMemberNewDiscussionReply
  circleMemberNewBroadcastReply

  """for circle members"""
  inCircleNewArticle
  inCircleNewBroadcast
  inCircleNewBroadcastReply
  inCircleNewDiscussion
  inCircleNewDiscussionReply
}

type OAuthClient {
  """Unique Client ID of this OAuth Client."""
  id: ID!

  """App name"""
  name: String!

  """App Description"""
  description: String

  """URL for oauth client's official website"""
  website: String

  """Scopes"""
  scope: [String!]

  """URL for oauth client's avatar."""
  avatar: String

  """Client secret"""
  secret: String!

  """Redirect URIs"""
  redirectURIs: [String!]

  """Grant Types"""
  grantTypes: [GrantType!]

  """Linked Developer Account"""
  user: User

  """Creation Date"""
  createdAt: DateTime!
}

type OAuthClientConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [OAuthClientEdge!]
}

type OAuthClientEdge {
  cursor: String!
  node: OAuthClient!
}

input OAuthClientInput {
  id: ID!
}

"""This type contains system-wise info and settings."""
type Official {
  """Feature flag"""
  features: [Feature!]!

  """Announcements"""
  announcements(input: AnnouncementsInput!): [Announcement!]
}

"""The notice type contains info about official announcement."""
type OfficialAnnouncementNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """The message content."""
  message: String!

  """The link to a specific page if provided."""
  link: String
}

scalar oldEmail_String_NotNull_format_email

type OSS {
  users(input: ConnectionArgs!): UserConnection!
  comments(input: ConnectionArgs!): CommentConnection!
  articles(input: ConnectionArgs!): ArticleConnection!
  tags(input: TagsInput!): TagConnection!
  oauthClients(input: ConnectionArgs!): OAuthClientConnection!
  skippedListItems(input: SkippedListItemsInput!): SkippedListItemsConnection!
  seedingUsers(input: ConnectionArgs!): UserConnection!
  badgedUsers(input: BadgedUsersInput!): UserConnection!
  restrictedUsers(input: ConnectionArgs!): UserConnection!
}

type PageInfo {
  startCursor: String
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
}

input PayoutInput {
  amount: amount_Float_NotNull_exclusiveMin_0!
  password: String!
}

input PayToInput {
  amount: amount_Float_NotNull_exclusiveMin_0!
  currency: TransactionCurrency!
  purpose: TransactionPurpose!
  recipientId: ID!
  targetId: ID

  """for HKD payment"""
  password: String

  """for USDT payment"""
  chain: Chain
  txHash: String
}

type PayToResult {
  transaction: Transaction!

  """Only available when paying with LIKE."""
  redirectUrl: String
}

type Person {
  email: email_String_NotNull_format_email!
}

input PinCommentInput {
  id: ID!
}

type Price {
  """Unique ID."""
  id: ID!

  """Amount of Price."""
  amount: Float!

  """Current Price belongs to whcih Circle."""
  circle: Circle!

  """Currency of Price."""
  currency: TransactionCurrency!

  """State of Price."""
  state: PriceState!

  """Created time."""
  createdAt: DateTime! @deprecated(reason: "No longer in use")

  """Updated time."""
  updatedAt: DateTime! @deprecated(reason: "No longer in use")
}

enum PriceState {
  active
  archived
}

input PublishArticleInput {
  id: ID!

  """whether publish to ISCN"""
  iscnPublish: Boolean
}

"""Enums for publishing state."""
enum PublishState {
  unpublished
  pending
  error
  published
}

input PutAnnouncementInput {
  id: ID
  title: String
  cover: String
  content: String
  link: link_String_format_uri
  type: AnnouncementType
  visible: Boolean
  order: Int
  translations: [TranslatedAnnouncementInput!]
}

input PutChapterInput {
  id: ID
  title: String
  description: String
  topic: ID
  articles: [ID!]
}

input PutCircleArticlesInput {
  """Circle ID"""
  id: ID!

  """Article Ids"""
  articles: [ID!]

  """Action Type"""
  type: PutCircleArticlesType!

  """Access Type, `public` or `paywall` only."""
  accessType: ArticleAccessType!
  license: ArticleLicenseType
}

enum PutCircleArticlesType {
  add
  remove
}

input PutCircleInput {
  """Unique ID."""
  id: ID

  """Unique ID of a Circle's avatar."""
  avatar: ID

  """Unique ID of a Circle's cover."""
  cover: ID

  """Slugified name of a Circle."""
  name: String

  """Human readable name of this Circle."""
  displayName: String

  """A short description of this Circle."""
  description: String

  """Circle's subscription fee."""
  amount: amount_Float_exclusiveMin_0
}

input PutCommentInput {
  comment: CommentInput!

  """edit comment if id is provided"""
  id: ID
}

input PutDraftInput {
  id: ID
  title: String
  summary: String
  content: String
  tags: [String!]
  cover: ID
  collection: [ID]
  circle: ID
  accessType: ArticleAccessType
  sensitive: Boolean
  license: ArticleLicenseType
  requestForDonation: requestForDonation_String_maxLength_140
  replyToDonator: replyToDonator_String_maxLength_140

  """whether publish to ISCN"""
  iscnPublish: Boolean

  """whether readers can comment"""
  canComment: Boolean
}

input PutOAuthClientInput {
  id: ID
  name: String
  description: String
  website: website_String_format_uri
  scope: [String!]
  avatar: ID
  secret: String
  redirectURIs: [String!]
  grantTypes: [GrantType!]
  user: ID
}

input PutRemarkInput {
  id: ID!
  remark: String!
  type: RemarkTypes!
}

input PutRestrictedUsersInput {
  ids: [ID!]!
  restrictions: [UserRestrictionType!]!
}

input PutSkippedListItemInput {
  id: ID
  type: SkippedListItemType
  value: String
  archived: Boolean
}

input PutTagInput {
  id: ID
  content: String
  cover: ID
  description: String
}

input PutTopicInput {
  id: ID
  title: String
  description: String
  cover: ID
  public: Boolean
  articles: [ID!]
  chapters: [ID!]
}

type Query {
  article(input: ArticleInput!): Article
  circle(input: CircleInput!): Circle
  node(input: NodeInput!): Node
  nodes(input: NodesInput!): [Node!]
  frequentSearch(input: FrequentSearchInput!): [String!]
  search(input: SearchInput!): SearchResultConnection!
  official: Official!
  oss: OSS!
  viewer: User
  user(input: UserInput!): User
  exchangeRates(input: ExchangeRatesInput): [ExchangeRate!]
  oauthClient(input: OAuthClientInput!): OAuthClient
}

enum QuoteCurrency {
  TWD
  HKD
  USD
}

scalar random_Int_min_0_max_49

input ReadArticleInput {
  id: ID!
}

type ReadHistory {
  article: Article!
  readAt: DateTime!
}

type ReadHistoryConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [ReadHistoryEdge!]
}

type ReadHistoryEdge {
  cursor: String!
  node: ReadHistory!
}

type RecentSearchConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [RecentSearchEdge!]
}

type RecentSearchEdge {
  cursor: String!
  node: String!
}

type Recommendation {
  """Activities based on user's following, sort by creation time."""
  following(input: ConnectionArgs!): FollowingActivityConnection!

  """Articles recommended based on recently read article tags."""
  readTagsArticles(input: ConnectionArgs!): ArticleConnection! @deprecated(reason: "Merged into following")

  """Global articles sort by publish time."""
  newest(input: ConnectionArgs!): ArticleConnection!

  """Global articles sort by latest activity time."""
  hottest(input: ConnectionArgs!): ArticleConnection!

  """'In case you missed it' recommendation."""
  icymi(input: ConnectionArgs!): ArticleConnection!

  """Global tag list, sort by activities in recent 14 days."""
  tags(input: RecommendInput!): TagConnection!

  """Hottest tag list"""
  hottestTags(input: RecommendInput!): TagConnection!

  """Selected tag list"""
  selectedTags(input: RecommendInput!): TagConnection!

  """Global user list, sort by activities in recent 6 month."""
  authors(input: RecommendInput!): UserConnection!

  """Global circles sort by created time."""
  newestCircles(input: ConnectionArgs!): CircleConnection!

  """Global circles sort by latest activity time."""
  hottestCircles(input: ConnectionArgs!): CircleConnection!
}

input RecommendInput {
  after: String
  first: first_Int_min_0
  oss: Boolean
  filter: FilterInput
  type: AuthorsType
}

"""Enums for types of recommend articles."""
enum RecommendTypes {
  icymi
  hottest
  newest
}

scalar redirectUrl_String_format_uri

input RefreshIPNSFeedInput {
  userName: String!

  """refresh how many recent articles, default to 50"""
  numArticles: Int = 50
}

input RelatedDonationArticlesInput {
  after: String
  first: first_Int_min_0
  oss: Boolean

  """index of article list, min: 0, max: 49"""
  random: random_Int_min_0_max_49
}

enum RemarkTypes {
  Article
  User
  Tag
  Comment
  Report
  Feedback
}

input RenameTagInput {
  id: ID!
  content: String!
}

scalar replyToDonator_String_maxLength_140

scalar requestForDonation_String_maxLength_140

input ResetLikerIdInput {
  id: ID!
}

input ResetPasswordInput {
  password: String!
  codeId: ID!
  type: ResetPasswordType
}

enum ResetPasswordType {
  account
  payment
}

input ResetWalletInput {
  id: ID!
}

union Response = Article | Comment

type ResponseConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [ResponseEdge!]
}

type ResponseEdge {
  cursor: String!
  node: Response!
}

input ResponsesInput {
  sort: ResponseSort
  after: String
  before: String
  includeAfter: Boolean
  includeBefore: Boolean
  first: first_Int_min_0
  articleOnly: Boolean
}

"""Enums for sorting responses."""
enum ResponseSort {
  oldest
  newest
}

"""Enums for user roles."""
enum Role {
  vistor
  user
  admin
}

enum SearchAPIVersion {
  v20230301
  v20221212
  v20221212prior
}

enum SearchExclude {
  blocked
}

input SearchFilter {
  authorId: ID
}

input SearchInput {
  """search keyword"""
  key: String!

  """types of search target"""
  type: SearchTypes!
  after: String
  first: first_Int_min_0

  """extra query filter for searching"""
  filter: SearchFilter

  """specific condition for rule data out"""
  exclude: SearchExclude

  """should include tags used by author"""
  includeAuthorTags: Boolean

  """whether this search operation should be recorded in search history"""
  record: Boolean
  oss: Boolean

  """deprecated, make no effect"""
  version: SearchAPIVersion

  """deprecated, make no effect"""
  coefficients: String
  quicksearch: Boolean
}

type SearchResultConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [SearchResultEdge!]
}

type SearchResultEdge {
  cursor: String!
  node: Node!
}

enum SearchTypes {
  Article
  User
  Tag
}

input SendVerificationCodeInput {
  email: email_String_NotNull_format_email!
  type: VerificationCodeType!
  token: String

  """
  Redirect URL embedded in the verification email,
  use code instead if not provided.
  """
  redirectUrl: redirectUrl_String_format_uri
}

input SetBoostInput {
  id: ID!
  boost: boost_Float_NotNull_min_0!
  type: BoostTypes!
}

input SetCurrencyInput {
  currency: QuoteCurrency
}

input SetFeatureInput {
  name: FeatureName!
  flag: FeatureFlag!
}

enum SigningMessagePurpose {
  airdrop
  connect
  signup
  login
  claimLogbook
}

type SigningMessageResult {
  nonce: String!
  purpose: SigningMessagePurpose!
  signingMessage: String!
  createdAt: DateTime!
  expiredAt: DateTime!
}

input SingleFileUploadInput {
  type: AssetType!
  file: Upload
  url: url_String_format_uri
  entityType: EntityType!
  entityId: ID
}

type SkippedListItem {
  id: ID!
  uuid: ID!
  type: SkippedListItemType!
  value: String!
  archived: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SkippedListItemEdge {
  cursor: String!
  node: SkippedListItem
}

type SkippedListItemsConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [SkippedListItemEdge!]
}

input SkippedListItemsInput {
  after: String
  first: first_Int_min_0
  type: SkippedListItemType
}

enum SkippedListItemType {
  agent_hash
  email
  domain
}

input SortTopicsInput {
  ids: [ID!]!
}

type StripeAccount {
  id: ID!
  loginUrl: String!
}

enum StripeAccountCountry {
  Australia
  Austria
  Belgium
  Bulgaria
  Canada
  Cyprus
  Denmark
  Estonia
  Finland
  France
  Germany
  Greece
  HongKong
  Ireland
  Italy
  Latvia
  Lithuania
  Luxembourg
  Malta
  Netherlands
  NewZealand
  Norway
  Poland
  Portugal
  Romania
  Singapore
  Slovakia
  Slovenia
  Spain
  Sweden
  UnitedKingdom
  UnitedStates
}

input SubscribeCircleInput {
  """Unique ID."""
  id: ID!

  """Wallet password."""
  password: String
}

type SubscribeCircleResult {
  circle: Circle!

  """client secret for SetupIntent."""
  client_secret: String
}

"""This type contains content, count and related data of an article tag."""
type Tag implements Node {
  """Unique id of this tag."""
  id: ID!

  """Content of this tag."""
  content: String!

  """List of how many articles were attached with this tag."""
  articles(input: TagArticlesInput!): ArticleConnection!

  """This value determines if this article is selected by this tag or not."""
  selected(input: TagSelectedInput!): Boolean!

  """Time of this tag was created."""
  createdAt: DateTime!

  """Tag's cover link."""
  cover: String

  """Description of this tag."""
  description: String

  """Editors of this tag."""
  editors(input: TagEditorsInput): [User!]

  """Creator of this tag."""
  creator: User

  """Owner of this tag."""
  owner: User

  """This value determines if current viewer is following or not."""
  isFollower: Boolean

  """This value determines if the tag is pinned by current viewer."""
  isPinned: Boolean

  """Followers of this tag."""
  followers(input: ConnectionArgs!): UserConnection!

  """Participants of this tag."""
  participants(input: ConnectionArgs!): UserConnection!

  """Tags recommended based on relations to current tag."""
  recommended(input: ConnectionArgs!): TagConnection!

  """This value determines if it is official."""
  isOfficial: Boolean

  """Counts of this tag."""
  numArticles: Int!
  numAuthors: Int!

  """
  #############
       OSS    #
  #############
  """
  oss: TagOSS!
  remark: String
  deleted: Boolean!
}

input TagArticlesInput {
  after: String
  first: first_Int_min_0
  oss: Boolean
  selected: Boolean
  sortBy: TagArticlesSortBy = byCreatedAtDesc
}

enum TagArticlesSortBy {
  byHottestDesc
  byCreatedAtDesc
}

type TagConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [TagEdge!]
}

type TagEdge {
  cursor: String!
  node: Tag!
}

input TagEditorsInput {
  excludeAdmin: Boolean
  excludeOwner: Boolean
}

type TagNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """List of notice actors."""
  actors: [User!]
  type: TagNoticeType!
  target: Tag!
}

enum TagNoticeType {
  TagAdoption
  TagLeave
  TagAddEditor
  TagLeaveEditor
}

type TagOSS {
  boost: Float!
  score: Float!
  selected: Boolean!
}

input TagSelectedInput {
  id: ID
  mediaHash: String
}

input TagsInput {
  after: String
  first: first_Int_min_0
  sort: TagsSort
}

"""Enums for sorting tags."""
enum TagsSort {
  newest
  oldest
  hottest
}

input ToggleCircleMemberInput {
  """Unique ID."""
  id: ID!

  """Toggle value."""
  enabled: Boolean!

  """Unique ID of target user."""
  targetId: ID!
}

"""Common input to toggle single item for `toggleXXX` mutations"""
input ToggleItemInput {
  id: ID!
  enabled: Boolean
}

input ToggleRecommendInput {
  id: ID!
  enabled: Boolean!
  type: RecommendTypes
}

input ToggleSeedingUsersInput {
  ids: [ID!]
  enabled: Boolean!
}

input ToggleUsersBadgeInput {
  ids: [ID!]
  type: BadgeType!
  enabled: Boolean!
}

type TopDonatorConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [TopDonatorEdge!]
}

type TopDonatorEdge {
  cursor: String!
  node: User!
  donationCount: Int!
}

input TopDonatorFilter {
  inRangeStart: DateTime
  inRangeEnd: DateTime
}

input TopDonatorInput {
  after: String
  first: Int
  filter: TopDonatorFilter
}

"""
This type contains metadata, content and related data of a topic, which is a container for Article and Chapter types.
"""
type Topic implements Node {
  """Unique id of this topic."""
  id: ID!

  """Title of this topic."""
  title: String!

  """Cover of this topic."""
  cover: String

  """Description of this topic."""
  description: String

  """Number of chapters included in this topic."""
  chapterCount: Int!

  """Number articles included in this topic."""
  articleCount: Int!

  """List of chapters included in this topic."""
  chapters: [Chapter!]

  """List of articles included in this topic."""
  articles: [Article!]

  """Author of this topic."""
  author: User!

  """Whether this topic is public or not."""
  public: Boolean!

  """Latest published article on this topic"""
  latestArticle: Article
}

type TopicConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [TopicEdge!]
}

type TopicEdge {
  cursor: String!
  node: Topic!
}

input TopicInput {
  after: String
  first: first_Int_min_0
  filter: FilterInput
}

type Transaction {
  id: ID!
  state: TransactionState!
  purpose: TransactionPurpose!
  amount: Float!
  fee: Float!
  currency: TransactionCurrency!

  """Timestamp of transaction."""
  createdAt: DateTime!

  """Recipient of transaction."""
  recipient: User

  """Sender of transaction."""
  sender: User

  """Related target article or transaction."""
  target: TransactionTarget

  """Message for end user, including reason of failure."""
  message: String

  """blockchain transaction info of USDT payment transaction"""
  blockchainTx: BlockchainTransaction
}

type TransactionConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [TransactionEdge!]
}

enum TransactionCurrency {
  HKD
  LIKE
  USDT
}

type TransactionEdge {
  cursor: String!
  node: Transaction!
}

"""
################################
                               #
         Transaction           #
                               #
################################
"""
type TransactionNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """List of notice actors."""
  actors: [User!]
  type: TransactionNoticeType!
  target: Transaction!
}

enum TransactionNoticeType {
  PaymentReceivedDonation
}

enum TransactionPurpose {
  donation
  addCredit
  refund
  payout
  subscriptionSplit
}

input TransactionsArgs {
  after: String
  first: first_Int_min_0

  """deprecated, use TransactionsFilter.id instead."""
  id: ID

  """deprecated, use TransactionsFilter.states instead."""
  states: [TransactionState!]
  filter: TransactionsFilter
}

input TransactionsFilter {
  id: ID
  states: [TransactionState!]
  currency: TransactionCurrency
  purpose: TransactionPurpose
}

input TransactionsReceivedByArgs {
  after: String
  first: first_Int_min_0
  purpose: TransactionPurpose!
  senderId: ID
}

enum TransactionState {
  pending
  succeeded
  failed
  canceled
}

union TransactionTarget = Article | Circle | Transaction

type TranslatedAnnouncement {
  language: UserLanguage!
  title: String
  cover: String
  content: String
  link: link_String_format_uri
}

input TranslatedAnnouncementInput {
  language: UserLanguage!
  title: String
  cover: String
  content: String
  link: link_String_format_uri
}

input TranslationArgs {
  language: UserLanguage!
}

input UnbindLikerIdInput {
  id: ID!
  likerId: String!
}

input UnpinCommentInput {
  id: ID!
}

input UnsubscribeCircleInput {
  """Unique ID."""
  id: ID!
}

input UnvoteCommentInput {
  id: ID!
}

input UpdateArticleSensitiveInput {
  id: ID!
  sensitive: Boolean!
}

input UpdateArticlesTagsInput {
  id: ID!
  articles: [ID!]
  isSelected: Boolean!
}

input UpdateArticleStateInput {
  id: ID!
  state: ArticleState!
}

input UpdateCommentsStateInput {
  ids: [ID!]!
  state: CommentState!
}

input UpdateNotificationSettingInput {
  type: NotificationSettingType!
  enabled: Boolean!
}

input UpdateTagSettingInput {
  id: ID!
  type: UpdateTagSettingType!
  editors: [ID!]
}

enum UpdateTagSettingType {
  adopt
  leave
  add_editor
  remove_editor
  leave_editor
}

input UpdateUserInfoInput {
  displayName: String
  userName: String
  avatar: ID
  description: String
  language: UserLanguage
  agreeOn: Boolean
  profileCover: ID
  paymentPassword: String
  paymentPointer: String
}

input UpdateUserRoleInput {
  id: ID!
  role: UserRole!
}

input UpdateUserStateInput {
  id: ID
  emails: [String!]
  state: UserState!
  banDays: banDays_Int_exclusiveMin_0
  password: String
}

scalar Upload

scalar url_String_format_uri

type User implements Node {
  """Global id of an user."""
  id: ID!

  """Global unique user name of a user."""
  userName: String

  """Display name on user profile, can be duplicated."""
  displayName: String

  """LikerID of LikeCoin, being used by LikeCoin OAuth"""
  likerId: String

  """Liker info of current user"""
  liker: Liker!

  """URL for user avatar."""
  avatar: String

  """User information."""
  info: UserInfo!

  """User settings."""
  settings: UserSettings!

  """Article recommendations for current user."""
  recommendation: Recommendation!

  """Articles authored by current user."""
  articles(input: ConnectionArgs!): ArticleConnection!

  """Topics created by current user."""
  topics(input: TopicInput!): TopicConnection!

  """Tags by by usage order of current user."""
  tags(input: ConnectionArgs!): TagConnection!

  """Tags owned and maintained by current user."""
  maintainedTags(input: ConnectionArgs!): TagConnection!

  """Tags pinned by current user."""
  pinnedTags(input: ConnectionArgs!): TagConnection!

  """Drafts authored by current user."""
  drafts(input: ConnectionArgs!): DraftConnection!

  """Articles current user commented on"""
  commentedArticles(input: ConnectionArgs!): ArticleConnection!

  """Artilces current user subscribed to."""
  subscriptions(input: ConnectionArgs!): ArticleConnection!

  """Record of user activity, only accessable by current user."""
  activity: UserActivity!

  """Followers of this user."""
  followers(input: ConnectionArgs!): UserConnection!

  """Following contents of this user."""
  following: Following!

  """Whether current user is following viewer."""
  isFollower: Boolean!

  """Whether viewer is following current user."""
  isFollowee: Boolean!

  """Users that blocked by current user."""
  blockList(input: ConnectionArgs!): UserConnection!

  """Whether current user is blocking viewer."""
  isBlocking: Boolean!

  """Whether current user is blocked by viewer."""
  isBlocked: Boolean!

  """user data analytics, only accessable by current user."""
  analytics: UserAnalytics!

  """Status of current user."""
  status: UserStatus

  """
  #############
       OSS    #
  #############
  """
  oss: UserOSS!
  remark: String

  """Circles belong to current user."""
  ownCircles: [Circle!]

  """Circles whiches user has subscribed."""
  subscribedCircles(input: ConnectionArgs!): CircleConnection!
  notices(input: ConnectionArgs!): NoticeConnection!

  """User Wallet"""
  wallet: Wallet!

  """Payment pointer that resolves to Open Payments endpoints"""
  paymentPointer: String
}

type UserActivity {
  """User reading history."""
  history(input: ConnectionArgs!): ReadHistoryConnection!

  """User search history."""
  recentSearches(input: ConnectionArgs!): RecentSearchConnection!

  """Appreciations current user gave."""
  appreciationsSent(input: ConnectionArgs!): AppreciationConnection!

  """Total number of appreciation current user gave."""
  appreciationsSentTotal: Int!

  """Appreciations current user received."""
  appreciationsReceived(input: ConnectionArgs!): AppreciationConnection!

  """Total number of appreciation current user received."""
  appreciationsReceivedTotal: Int!
}

type UserAddArticleTagActivity {
  actor: User!
  createdAt: DateTime!

  """Article added to tag"""
  node: Article!

  """Tag added by article"""
  target: Tag!
}

type UserAnalytics {
  """Top donators of current user."""
  topDonators(input: TopDonatorInput!): TopDonatorConnection!
}

type UserBroadcastCircleActivity {
  actor: User!
  createdAt: DateTime!

  """Comment broadcast by actor"""
  node: Comment!

  """Circle that comment belongs to"""
  target: Circle!
}

type UserConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [UserEdge!]
}

type UserCreateCircleActivity {
  actor: User!
  createdAt: DateTime!

  """Circle created by actor"""
  node: Circle!
}

type UserEdge {
  cursor: String!
  node: User!
}

enum UserGroup {
  a
  b
}

type UserInfo {
  """Timestamp of registration."""
  createdAt: DateTime

  """Is user name editable."""
  userNameEditable: Boolean!

  """User desciption."""
  description: String

  """
  the ipnsKey (`ipfs.io/ipns/<ipnsKey>/...`) for feed.json / rss.xml / index
  """
  ipnsKey: String

  """User email."""
  email: email_String_format_email

  """User badges."""
  badges: [Badge!]

  """Timestamp of user agreement."""
  agreeOn: DateTime

  """Cover of profile page."""
  profileCover: String

  """Type of group."""
  group: UserGroup!

  """Login address"""
  ethAddress: String
  isWalletAuth: Boolean!

  """Connected wallet."""
  cryptoWallet: CryptoWallet

  """
  saved tags for showing on profile page, API allows up to 100, front-end lock'ed at lower limit
  """
  featuredTags: [Tag!]
}

enum UserInfoFields {
  displayName
  avatar
  description
  email
  agreeOn
}

input UserInput {
  userName: String
  ethAddress: String
}

enum UserLanguage {
  en
  zh_hans
  zh_hant
}

input UserLoginInput {
  email: email_String_NotNull_format_email!
  password: String!
}

"""
################################
                               #
             User              #
                               #
################################
"""
type UserNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """List of notice actors."""
  actors: [User!]
  type: UserNoticeType!
  target: User!
}

enum UserNoticeType {
  UserNewFollower
}

type UserOSS {
  boost: Float!
  score: Float!
  restrictions: [UserRestriction!]!
}

type UserPublishArticleActivity {
  actor: User!
  createdAt: DateTime!

  """Article published by actor"""
  node: Article!
}

type UserRecommendationActivity {
  """The source type of recommendation"""
  source: UserRecommendationActivitySource

  """Recommended users"""
  nodes: [User!]
}

enum UserRecommendationActivitySource {
  UserFollowing
}

input UserRegisterInput {
  email: email_String_NotNull_format_email!
  userName: String
  displayName: String!
  password: String!
  description: String
  codeId: ID!
}

type UserRestriction {
  type: UserRestrictionType!
  createdAt: DateTime!
}

enum UserRestrictionType {
  articleHottest
  articleNewest
}

enum UserRole {
  user
  admin
}

type UserSettings {
  """User language setting."""
  language: UserLanguage!

  """User currency preference."""
  currency: QuoteCurrency!

  """Notification settings."""
  notification: NotificationSetting
}

enum UserState {
  active
  onboarding
  banned
  archived
  frozen
}

type UserStatus {
  """User state."""
  state: UserState!

  """User role and access level."""
  role: UserRole!

  """Number of articles published by user"""
  articleCount: Int!

  """Number of comments posted by user."""
  commentCount: Int!

  """Number of unread notices."""
  unreadNoticeCount: Int!

  """Whether there are unread activities from following."""
  unreadFollowing: Boolean!

  """Number of total written words."""
  totalWordCount: Int!

  """Whether user already set payment password."""
  hasPaymentPassword: Boolean!

  """Number of articles donated by user"""
  donatedArticleCount: Int!

  """Number of times of donations received by user"""
  receivedDonationCount: Int!
}

enum VerificationCodeType {
  register
  email_reset
  email_reset_confirm
  password_reset
  payment_password_reset
}

input VerifyEmailInput {
  codeId: ID!
}

"""Enums for vote types."""
enum Vote {
  up
  down
}

input VoteCommentInput {
  vote: Vote!
  id: ID!
}

type Wallet {
  balance: Balance!
  transactions(input: TransactionsArgs!): TransactionConnection!

  """Account of Stripe Connect to manage payout"""
  stripeAccount: StripeAccount

  """
  URL of Stripe Dashboard to manage subscription invoice and payment method
  """
  customerPortal: String

  """The last four digits of the card."""
  cardLast4: String
}

input WalletLoginInput {
  ethAddress: String!

  """the message being sign'ed, including nonce"""
  signedMessage: String!

  """sign'ed by wallet"""
  signature: String!

  """nonce from generateSigningMessage"""
  nonce: String!

  """required for wallet register"""
  email: email_String_format_email

  """email verification code, required for wallet register"""
  codeId: ID
}

scalar website_String_format_uri
